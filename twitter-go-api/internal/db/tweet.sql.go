// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tweet.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createRetweet = `-- name: CreateRetweet :one
WITH inserted AS (
  INSERT INTO tweets (user_id, retweet_id, media_type)
  VALUES ($1, $2, 'NONE')
  ON CONFLICT DO NOTHING
  RETURNING id, user_id, content, media_type, media_url, parent_id, retweet_id, reply_count, retweet_count, like_count, created_at, updated_at, search_vector
),
updated AS (
  UPDATE tweets
  SET retweet_count = retweet_count + 1
  WHERE id = $2 AND EXISTS (SELECT 1 FROM inserted)
)
SELECT id, user_id, content, media_type, media_url, parent_id, retweet_id, reply_count, retweet_count, like_count, created_at, updated_at, search_vector FROM inserted
`

type CreateRetweetParams struct {
	UserID    int64         `json:"user_id"`
	RetweetID sql.NullInt64 `json:"retweet_id"`
}

type CreateRetweetRow struct {
	ID           int64          `json:"id"`
	UserID       int64          `json:"user_id"`
	Content      sql.NullString `json:"content"`
	MediaType    sql.NullString `json:"media_type"`
	MediaUrl     sql.NullString `json:"media_url"`
	ParentID     sql.NullInt64  `json:"parent_id"`
	RetweetID    sql.NullInt64  `json:"retweet_id"`
	ReplyCount   int32          `json:"reply_count"`
	RetweetCount int32          `json:"retweet_count"`
	LikeCount    int32          `json:"like_count"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	SearchVector interface{}    `json:"search_vector"`
}

func (q *Queries) CreateRetweet(ctx context.Context, arg CreateRetweetParams) (CreateRetweetRow, error) {
	row := q.db.QueryRowContext(ctx, createRetweet, arg.UserID, arg.RetweetID)
	var i CreateRetweetRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.MediaType,
		&i.MediaUrl,
		&i.ParentID,
		&i.RetweetID,
		&i.ReplyCount,
		&i.RetweetCount,
		&i.LikeCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const createTweet = `-- name: CreateTweet :one
INSERT INTO tweets (
  user_id, content, media_type, media_url, parent_id, retweet_id
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, user_id, content, media_type, media_url, parent_id, retweet_id, reply_count, retweet_count, like_count, created_at, updated_at, search_vector
`

type CreateTweetParams struct {
	UserID    int64          `json:"user_id"`
	Content   sql.NullString `json:"content"`
	MediaType sql.NullString `json:"media_type"`
	MediaUrl  sql.NullString `json:"media_url"`
	ParentID  sql.NullInt64  `json:"parent_id"`
	RetweetID sql.NullInt64  `json:"retweet_id"`
}

func (q *Queries) CreateTweet(ctx context.Context, arg CreateTweetParams) (Tweet, error) {
	row := q.db.QueryRowContext(ctx, createTweet,
		arg.UserID,
		arg.Content,
		arg.MediaType,
		arg.MediaUrl,
		arg.ParentID,
		arg.RetweetID,
	)
	var i Tweet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.MediaType,
		&i.MediaUrl,
		&i.ParentID,
		&i.RetweetID,
		&i.ReplyCount,
		&i.RetweetCount,
		&i.LikeCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const decrementParentReplyCount = `-- name: DecrementParentReplyCount :exec
UPDATE tweets
SET reply_count = GREATEST(0, reply_count - 1)
WHERE id = $1
`

func (q *Queries) DecrementParentReplyCount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, decrementParentReplyCount, id)
	return err
}

const deleteRetweetByUser = `-- name: DeleteRetweetByUser :one
WITH deleted AS (
DELETE FROM tweets
WHERE tweets.user_id = $1 AND tweets.retweet_id = $2
RETURNING id, user_id, content, media_type, media_url, parent_id, retweet_id, reply_count, retweet_count, like_count, created_at, updated_at, search_vector
),
updated AS (
  UPDATE tweets
  SET retweet_count = GREATEST(0, retweet_count - 1)
  WHERE id = $2 AND EXISTS (SELECT 1 FROM deleted)
)
SELECT id, user_id, content, media_type, media_url, parent_id, retweet_id, reply_count, retweet_count, like_count, created_at, updated_at, search_vector FROM deleted
`

type DeleteRetweetByUserParams struct {
	UserID    int64         `json:"user_id"`
	RetweetID sql.NullInt64 `json:"retweet_id"`
}

type DeleteRetweetByUserRow struct {
	ID           int64          `json:"id"`
	UserID       int64          `json:"user_id"`
	Content      sql.NullString `json:"content"`
	MediaType    sql.NullString `json:"media_type"`
	MediaUrl     sql.NullString `json:"media_url"`
	ParentID     sql.NullInt64  `json:"parent_id"`
	RetweetID    sql.NullInt64  `json:"retweet_id"`
	ReplyCount   int32          `json:"reply_count"`
	RetweetCount int32          `json:"retweet_count"`
	LikeCount    int32          `json:"like_count"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	SearchVector interface{}    `json:"search_vector"`
}

func (q *Queries) DeleteRetweetByUser(ctx context.Context, arg DeleteRetweetByUserParams) (DeleteRetweetByUserRow, error) {
	row := q.db.QueryRowContext(ctx, deleteRetweetByUser, arg.UserID, arg.RetweetID)
	var i DeleteRetweetByUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.MediaType,
		&i.MediaUrl,
		&i.ParentID,
		&i.RetweetID,
		&i.ReplyCount,
		&i.RetweetCount,
		&i.LikeCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const deleteTweetByOwner = `-- name: DeleteTweetByOwner :one
DELETE FROM tweets
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, content, media_type, media_url, parent_id, retweet_id, reply_count, retweet_count, like_count, created_at, updated_at, search_vector
`

type DeleteTweetByOwnerParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeleteTweetByOwner(ctx context.Context, arg DeleteTweetByOwnerParams) (Tweet, error) {
	row := q.db.QueryRowContext(ctx, deleteTweetByOwner, arg.ID, arg.UserID)
	var i Tweet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.MediaType,
		&i.MediaUrl,
		&i.ParentID,
		&i.RetweetID,
		&i.ReplyCount,
		&i.RetweetCount,
		&i.LikeCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const getTweet = `-- name: GetTweet :one
SELECT ts.id, ts.user_id, ts.content, ts.media_type, ts.media_url, ts.parent_id, ts.retweet_id, ts.reply_count, ts.retweet_count, ts.like_count, ts.created_at, ts.updated_at, ts.search_vector,
  EXISTS(SELECT 1 FROM tweet_likes tl WHERE tl.tweet_id = ts.id AND tl.user_id = $2) AS is_liked,
  EXISTS(SELECT 1 FROM tweets tr WHERE tr.retweet_id = ts.id AND tr.user_id = $2) AS is_retweeted,
  EXISTS(SELECT 1 FROM follows f WHERE f.following_id = ts.user_id AND f.follower_id = $2) AS is_following
FROM tweets ts
WHERE ts.id = $1 LIMIT 1
`

type GetTweetParams struct {
	ID       int64         `json:"id"`
	ViewerID sql.NullInt64 `json:"viewer_id"`
}

type GetTweetRow struct {
	ID           int64          `json:"id"`
	UserID       int64          `json:"user_id"`
	Content      sql.NullString `json:"content"`
	MediaType    sql.NullString `json:"media_type"`
	MediaUrl     sql.NullString `json:"media_url"`
	ParentID     sql.NullInt64  `json:"parent_id"`
	RetweetID    sql.NullInt64  `json:"retweet_id"`
	ReplyCount   int32          `json:"reply_count"`
	RetweetCount int32          `json:"retweet_count"`
	LikeCount    int32          `json:"like_count"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	SearchVector interface{}    `json:"search_vector"`
	IsLiked      bool           `json:"is_liked"`
	IsRetweeted  bool           `json:"is_retweeted"`
	IsFollowing  bool           `json:"is_following"`
}

func (q *Queries) GetTweet(ctx context.Context, arg GetTweetParams) (GetTweetRow, error) {
	row := q.db.QueryRowContext(ctx, getTweet, arg.ID, arg.ViewerID)
	var i GetTweetRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.MediaType,
		&i.MediaUrl,
		&i.ParentID,
		&i.RetweetID,
		&i.ReplyCount,
		&i.RetweetCount,
		&i.LikeCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
		&i.IsLiked,
		&i.IsRetweeted,
		&i.IsFollowing,
	)
	return i, err
}

const getUserRetweet = `-- name: GetUserRetweet :one
SELECT id, user_id, content, media_type, media_url, parent_id, retweet_id, reply_count, retweet_count, like_count, created_at, updated_at, search_vector FROM tweets
WHERE user_id = $1 AND retweet_id = $2
LIMIT 1
`

type GetUserRetweetParams struct {
	UserID    int64         `json:"user_id"`
	RetweetID sql.NullInt64 `json:"retweet_id"`
}

func (q *Queries) GetUserRetweet(ctx context.Context, arg GetUserRetweetParams) (Tweet, error) {
	row := q.db.QueryRowContext(ctx, getUserRetweet, arg.UserID, arg.RetweetID)
	var i Tweet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.MediaType,
		&i.MediaUrl,
		&i.ParentID,
		&i.RetweetID,
		&i.ReplyCount,
		&i.RetweetCount,
		&i.LikeCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SearchVector,
	)
	return i, err
}

const incrementParentReplyCount = `-- name: IncrementParentReplyCount :exec
UPDATE tweets
SET reply_count = reply_count + 1
WHERE id = $1
`

func (q *Queries) IncrementParentReplyCount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, incrementParentReplyCount, id)
	return err
}

const listFollowingFeed = `-- name: ListFollowingFeed :many
SELECT t.id, t.user_id, t.content, t.media_type, t.media_url, t.parent_id, t.retweet_id, t.reply_count, t.retweet_count, t.like_count, t.created_at, t.updated_at, t.search_vector,
  EXISTS(SELECT 1 FROM tweet_likes tl WHERE tl.tweet_id = t.id AND tl.user_id = $4) AS is_liked,
  EXISTS(SELECT 1 FROM tweets tr WHERE tr.retweet_id = t.id AND tr.user_id = $4) AS is_retweeted,
  true AS is_following
FROM tweets t
JOIN follows f ON t.user_id = f.following_id
WHERE f.follower_id = $1
  AND t.parent_id IS NULL
ORDER BY t.created_at DESC
LIMIT $2 OFFSET $3
`

type ListFollowingFeedParams struct {
	FollowerID int64         `json:"follower_id"`
	Limit      int32         `json:"limit"`
	Offset     int32         `json:"offset"`
	ViewerID   sql.NullInt64 `json:"viewer_id"`
}

type ListFollowingFeedRow struct {
	ID           int64          `json:"id"`
	UserID       int64          `json:"user_id"`
	Content      sql.NullString `json:"content"`
	MediaType    sql.NullString `json:"media_type"`
	MediaUrl     sql.NullString `json:"media_url"`
	ParentID     sql.NullInt64  `json:"parent_id"`
	RetweetID    sql.NullInt64  `json:"retweet_id"`
	ReplyCount   int32          `json:"reply_count"`
	RetweetCount int32          `json:"retweet_count"`
	LikeCount    int32          `json:"like_count"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	SearchVector interface{}    `json:"search_vector"`
	IsLiked      bool           `json:"is_liked"`
	IsRetweeted  bool           `json:"is_retweeted"`
	IsFollowing  bool           `json:"is_following"`
}

func (q *Queries) ListFollowingFeed(ctx context.Context, arg ListFollowingFeedParams) ([]ListFollowingFeedRow, error) {
	rows, err := q.db.QueryContext(ctx, listFollowingFeed,
		arg.FollowerID,
		arg.Limit,
		arg.Offset,
		arg.ViewerID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFollowingFeedRow{}
	for rows.Next() {
		var i ListFollowingFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.MediaType,
			&i.MediaUrl,
			&i.ParentID,
			&i.RetweetID,
			&i.ReplyCount,
			&i.RetweetCount,
			&i.LikeCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.IsLiked,
			&i.IsRetweeted,
			&i.IsFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listForYouFeed = `-- name: ListForYouFeed :many
SELECT t.id, t.user_id, t.content, t.media_type, t.media_url, t.parent_id, t.retweet_id, t.reply_count, t.retweet_count, t.like_count, t.created_at, t.updated_at, t.search_vector,
  EXISTS(SELECT 1 FROM tweet_likes tl WHERE tl.tweet_id = t.id AND tl.user_id = $3) AS is_liked,
  EXISTS(SELECT 1 FROM tweets tr WHERE tr.retweet_id = t.id AND tr.user_id = $3) AS is_retweeted,
  EXISTS(SELECT 1 FROM follows f WHERE f.following_id = t.user_id AND f.follower_id = $3) AS is_following
FROM tweets t
WHERE t.parent_id IS NULL
ORDER BY
  (t.like_count * 2 + t.retweet_count * 3 + t.reply_count + 1) /
  POWER((EXTRACT(EPOCH FROM NOW() - t.created_at) / 3600) + 2, 1.8) DESC,
  t.created_at DESC
LIMIT $1 OFFSET $2
`

type ListForYouFeedParams struct {
	Limit    int32         `json:"limit"`
	Offset   int32         `json:"offset"`
	ViewerID sql.NullInt64 `json:"viewer_id"`
}

type ListForYouFeedRow struct {
	ID           int64          `json:"id"`
	UserID       int64          `json:"user_id"`
	Content      sql.NullString `json:"content"`
	MediaType    sql.NullString `json:"media_type"`
	MediaUrl     sql.NullString `json:"media_url"`
	ParentID     sql.NullInt64  `json:"parent_id"`
	RetweetID    sql.NullInt64  `json:"retweet_id"`
	ReplyCount   int32          `json:"reply_count"`
	RetweetCount int32          `json:"retweet_count"`
	LikeCount    int32          `json:"like_count"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	SearchVector interface{}    `json:"search_vector"`
	IsLiked      bool           `json:"is_liked"`
	IsRetweeted  bool           `json:"is_retweeted"`
	IsFollowing  bool           `json:"is_following"`
}

func (q *Queries) ListForYouFeed(ctx context.Context, arg ListForYouFeedParams) ([]ListForYouFeedRow, error) {
	rows, err := q.db.QueryContext(ctx, listForYouFeed, arg.Limit, arg.Offset, arg.ViewerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListForYouFeedRow{}
	for rows.Next() {
		var i ListForYouFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.MediaType,
			&i.MediaUrl,
			&i.ParentID,
			&i.RetweetID,
			&i.ReplyCount,
			&i.RetweetCount,
			&i.LikeCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.IsLiked,
			&i.IsRetweeted,
			&i.IsFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTweetReplies = `-- name: ListTweetReplies :many
SELECT t.id, t.user_id, t.content, t.media_type, t.media_url, t.parent_id, t.retweet_id, t.reply_count, t.retweet_count, t.like_count, t.created_at, t.updated_at, t.search_vector,
  EXISTS(SELECT 1 FROM tweet_likes tl WHERE tl.tweet_id = t.id AND tl.user_id = $4) AS is_liked,
  EXISTS(SELECT 1 FROM tweets tr WHERE tr.retweet_id = t.id AND tr.user_id = $4) AS is_retweeted,
  EXISTS(SELECT 1 FROM follows f WHERE f.following_id = t.user_id AND f.follower_id = $4) AS is_following
FROM tweets t
WHERE t.parent_id = $1
ORDER BY t.created_at ASC
LIMIT $2 OFFSET $3
`

type ListTweetRepliesParams struct {
	ParentID sql.NullInt64 `json:"parent_id"`
	Limit    int32         `json:"limit"`
	Offset   int32         `json:"offset"`
	ViewerID sql.NullInt64 `json:"viewer_id"`
}

type ListTweetRepliesRow struct {
	ID           int64          `json:"id"`
	UserID       int64          `json:"user_id"`
	Content      sql.NullString `json:"content"`
	MediaType    sql.NullString `json:"media_type"`
	MediaUrl     sql.NullString `json:"media_url"`
	ParentID     sql.NullInt64  `json:"parent_id"`
	RetweetID    sql.NullInt64  `json:"retweet_id"`
	ReplyCount   int32          `json:"reply_count"`
	RetweetCount int32          `json:"retweet_count"`
	LikeCount    int32          `json:"like_count"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	SearchVector interface{}    `json:"search_vector"`
	IsLiked      bool           `json:"is_liked"`
	IsRetweeted  bool           `json:"is_retweeted"`
	IsFollowing  bool           `json:"is_following"`
}

func (q *Queries) ListTweetReplies(ctx context.Context, arg ListTweetRepliesParams) ([]ListTweetRepliesRow, error) {
	rows, err := q.db.QueryContext(ctx, listTweetReplies,
		arg.ParentID,
		arg.Limit,
		arg.Offset,
		arg.ViewerID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTweetRepliesRow{}
	for rows.Next() {
		var i ListTweetRepliesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.MediaType,
			&i.MediaUrl,
			&i.ParentID,
			&i.RetweetID,
			&i.ReplyCount,
			&i.RetweetCount,
			&i.LikeCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.IsLiked,
			&i.IsRetweeted,
			&i.IsFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserTweets = `-- name: ListUserTweets :many
SELECT t.id, t.user_id, t.content, t.media_type, t.media_url, t.parent_id, t.retweet_id, t.reply_count, t.retweet_count, t.like_count, t.created_at, t.updated_at, t.search_vector,
  EXISTS(SELECT 1 FROM tweet_likes tl WHERE tl.tweet_id = t.id AND tl.user_id = $4) AS is_liked,
  EXISTS(SELECT 1 FROM tweets tr WHERE tr.retweet_id = t.id AND tr.user_id = $4) AS is_retweeted,
  EXISTS(SELECT 1 FROM follows f WHERE f.following_id = t.user_id AND f.follower_id = $4) AS is_following
FROM tweets t
WHERE t.user_id = $1
  AND t.parent_id IS NULL
ORDER BY t.created_at DESC
LIMIT $2 OFFSET $3
`

type ListUserTweetsParams struct {
	UserID   int64         `json:"user_id"`
	Limit    int32         `json:"limit"`
	Offset   int32         `json:"offset"`
	ViewerID sql.NullInt64 `json:"viewer_id"`
}

type ListUserTweetsRow struct {
	ID           int64          `json:"id"`
	UserID       int64          `json:"user_id"`
	Content      sql.NullString `json:"content"`
	MediaType    sql.NullString `json:"media_type"`
	MediaUrl     sql.NullString `json:"media_url"`
	ParentID     sql.NullInt64  `json:"parent_id"`
	RetweetID    sql.NullInt64  `json:"retweet_id"`
	ReplyCount   int32          `json:"reply_count"`
	RetweetCount int32          `json:"retweet_count"`
	LikeCount    int32          `json:"like_count"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	SearchVector interface{}    `json:"search_vector"`
	IsLiked      bool           `json:"is_liked"`
	IsRetweeted  bool           `json:"is_retweeted"`
	IsFollowing  bool           `json:"is_following"`
}

func (q *Queries) ListUserTweets(ctx context.Context, arg ListUserTweetsParams) ([]ListUserTweetsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserTweets,
		arg.UserID,
		arg.Limit,
		arg.Offset,
		arg.ViewerID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserTweetsRow{}
	for rows.Next() {
		var i ListUserTweetsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.MediaType,
			&i.MediaUrl,
			&i.ParentID,
			&i.RetweetID,
			&i.ReplyCount,
			&i.RetweetCount,
			&i.LikeCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.IsLiked,
			&i.IsRetweeted,
			&i.IsFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTweetsByHashtag = `-- name: SearchTweetsByHashtag :many
SELECT t.id, t.user_id, t.content, t.media_type, t.media_url, t.parent_id, t.retweet_id, t.reply_count, t.retweet_count, t.like_count, t.created_at, t.updated_at, t.search_vector,
  EXISTS(SELECT 1 FROM tweet_likes tl WHERE tl.tweet_id = t.id AND tl.user_id = $4) AS is_liked,
  EXISTS(SELECT 1 FROM tweets tr WHERE tr.retweet_id = t.id AND tr.user_id = $4) AS is_retweeted,
  EXISTS(SELECT 1 FROM follows f WHERE f.following_id = t.user_id AND f.follower_id = $4) AS is_following
FROM tweets t
JOIN tweet_hashtags th ON th.tweet_id = t.id
JOIN hashtags h ON h.id = th.hashtag_id
WHERE LOWER(h.text) = LOWER($1)
ORDER BY t.created_at DESC
LIMIT $2 OFFSET $3
`

type SearchTweetsByHashtagParams struct {
	Lower    string        `json:"lower"`
	Limit    int32         `json:"limit"`
	Offset   int32         `json:"offset"`
	ViewerID sql.NullInt64 `json:"viewer_id"`
}

type SearchTweetsByHashtagRow struct {
	ID           int64          `json:"id"`
	UserID       int64          `json:"user_id"`
	Content      sql.NullString `json:"content"`
	MediaType    sql.NullString `json:"media_type"`
	MediaUrl     sql.NullString `json:"media_url"`
	ParentID     sql.NullInt64  `json:"parent_id"`
	RetweetID    sql.NullInt64  `json:"retweet_id"`
	ReplyCount   int32          `json:"reply_count"`
	RetweetCount int32          `json:"retweet_count"`
	LikeCount    int32          `json:"like_count"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	SearchVector interface{}    `json:"search_vector"`
	IsLiked      bool           `json:"is_liked"`
	IsRetweeted  bool           `json:"is_retweeted"`
	IsFollowing  bool           `json:"is_following"`
}

func (q *Queries) SearchTweetsByHashtag(ctx context.Context, arg SearchTweetsByHashtagParams) ([]SearchTweetsByHashtagRow, error) {
	rows, err := q.db.QueryContext(ctx, searchTweetsByHashtag,
		arg.Lower,
		arg.Limit,
		arg.Offset,
		arg.ViewerID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchTweetsByHashtagRow{}
	for rows.Next() {
		var i SearchTweetsByHashtagRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.MediaType,
			&i.MediaUrl,
			&i.ParentID,
			&i.RetweetID,
			&i.ReplyCount,
			&i.RetweetCount,
			&i.LikeCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.IsLiked,
			&i.IsRetweeted,
			&i.IsFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTweetsFullText = `-- name: SearchTweetsFullText :many
SELECT t.id, t.user_id, t.content, t.media_type, t.media_url, t.parent_id, t.retweet_id, t.reply_count, t.retweet_count, t.like_count, t.created_at, t.updated_at, t.search_vector,
  EXISTS(SELECT 1 FROM tweet_likes tl WHERE tl.tweet_id = t.id AND tl.user_id = $4) AS is_liked,
  EXISTS(SELECT 1 FROM tweets tr WHERE tr.retweet_id = t.id AND tr.user_id = $4) AS is_retweeted,
  EXISTS(SELECT 1 FROM follows f WHERE f.following_id = t.user_id AND f.follower_id = $4) AS is_following
FROM tweets t
WHERE t.search_vector @@ to_tsquery('english', $1)
ORDER BY ts_rank(t.search_vector, to_tsquery('english', $1)) DESC, t.created_at DESC
LIMIT $2 OFFSET $3
`

type SearchTweetsFullTextParams struct {
	ToTsquery string        `json:"to_tsquery"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
	ViewerID  sql.NullInt64 `json:"viewer_id"`
}

type SearchTweetsFullTextRow struct {
	ID           int64          `json:"id"`
	UserID       int64          `json:"user_id"`
	Content      sql.NullString `json:"content"`
	MediaType    sql.NullString `json:"media_type"`
	MediaUrl     sql.NullString `json:"media_url"`
	ParentID     sql.NullInt64  `json:"parent_id"`
	RetweetID    sql.NullInt64  `json:"retweet_id"`
	ReplyCount   int32          `json:"reply_count"`
	RetweetCount int32          `json:"retweet_count"`
	LikeCount    int32          `json:"like_count"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	SearchVector interface{}    `json:"search_vector"`
	IsLiked      bool           `json:"is_liked"`
	IsRetweeted  bool           `json:"is_retweeted"`
	IsFollowing  bool           `json:"is_following"`
}

func (q *Queries) SearchTweetsFullText(ctx context.Context, arg SearchTweetsFullTextParams) ([]SearchTweetsFullTextRow, error) {
	rows, err := q.db.QueryContext(ctx, searchTweetsFullText,
		arg.ToTsquery,
		arg.Limit,
		arg.Offset,
		arg.ViewerID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchTweetsFullTextRow{}
	for rows.Next() {
		var i SearchTweetsFullTextRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.MediaType,
			&i.MediaUrl,
			&i.ParentID,
			&i.RetweetID,
			&i.ReplyCount,
			&i.RetweetCount,
			&i.LikeCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SearchVector,
			&i.IsLiked,
			&i.IsRetweeted,
			&i.IsFollowing,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
